---
title: 스프링 입문 1. 스프링과 웹 애플리케이션
author: breadkey
categories: study
tags: spring
layout: post
---
## 스프링의 최신 정보
> ### 스프링의 역사
>> 2002년 등장  
2006년 SSH(스트럿츠, 스프링, 하이버네이트)구성으로 웹 애플리케이션 프레임워크로 이용
>>> 현재는 스트럿츠 < 스프링MVC

> ### 스프링 서브 포르젝트
* 초기  
    **스프링 웹 플로**: 화면 전환의 흐름을 관리
* 추가  
    **스프링 시큐리티**: 인증/허가 처리를 관리  
    **스프링 배치**: 일괄 처리용
* 최근  
    **스프링 부트**: 애플리케이션 개발을 간단하게 해줌

>> 웹 애플리케이션 기반에서 엔터프라이즈 시스템의 기반으로, 비즈니스 아이디어를 시스템으로 빠르게 만들어줄 수 있는 기반으로 발전하였다.  
작은 시스템부터 큰 시스템까지 모두 대응 가능하다.

> ### 스프링의 국내 동향
>> 전자 정부 표준 프레임워크와 기반 기술

> ### 한국 스프링 사용자 모임
>> 비영리적 컨퍼런스 스프링 캠프

> ### 스프링 교육 관련 정보
>> [공식 교육 과정](https://pivotal.io/kr/learn)  
자격 시험 존재하지만 영어로만 제공

* * *
## 스프링과 웹 애플리케이션
> 스프링은 웹앱에 특화된 프레임워크가 아니라 규모가 큰 애플리케이션을 자바로 만들 때 필요한 프레임워크이다.  
구현을 위한 프레임워크가 아닌 **설계를 위한 프레임워크**이다.

> ### 웹 애플리케이션이란?
>> #### WWW가 유행하게 된 이유
>>> 컴퓨터와 인연이 없는 사람도 컴퓨터를 켜고 웹 브라우저만 사용할 수 있으면 간단히 이용할 수 있는 기술이기 때문이다.

>> #### 웹 시스템의 기본적인 구조
>>> **정적 콘텐츠**: 클라이언트의 웹 브라우저가 웹 서버로부터 요청한 HTML을 읽어와서 표시한다.  
　  
**동적 콘텐츠**: 웹 서버에서 애플리케이션 서버에 처리를 요청하고 처리 결과(대부분 RDB에서 데이터를 읽어오거나 가공)를 웹 서버에서 받아 웹 브라우저에 표시한다.  
　  
**현재**: Ajax등으로 웹 브라우저에 풍부한 화면을 구현할 수 있다. RDB 대신 KVS를 사용하는 경우도 많고, 클라이언트가 스마트폰인 경우도 많다. 서비스의 실체가 클라우드 안에 숨어있어 단순히 메일같은 인터넷상의 서비스로 존재할 때도 있지만 기본적인 동작은 위와 다를게 없다.  
　  
구체적으로 다음과 같은 동작의 반복이다.
1. 웹 브라우저에서 버튼을 클릭
2. 버튼에 대응한 비즈니스 로직이 RDB의 데이터를 이용해서 처리 진행
3. 처리 결과를 전송
4. 웹 브라우저에 표시

>>> 주의해야할 점은 "3. 처리 결과를 전송"" 후 세션이 끊어져버리는 것이다. 이렇게 되면 **상태를 저장할 수 없다**.(물론 이는 **HTTP 1.1+** 등 현재의 기술로 당연히 해결 가능하다.)  

>> #### 자바 엔터프라이즈의 역사
* HTML
	* 정적 콘텐츠
* CGI
	* 동적 콘텐츠이나 1요청 1프로세스로 세션 관리가 없다.
* 서블릿, JSP
	* CGI의 문제점을 해결했으며 자바를 사용한다.
* EJB(3.0 이전)
	* 컴포넌트 모델의 업계 표준이며 분산 오브젝트를 지원한다.
* 스프링
	* J2EE의 단점을 개선하려는 목적으로 만들어 졌으며 현재 클라우드 시대를 주도하고있다.

>> **스프링을 왜 쓰는지 이해하려면 과거 기술들의 문제점을 알아야 한다.**

> ### JSP, Servlet의 등장
>> 단순히 정적 콘텐츠만 표시하는 것은 업무에 이용하기에 기능이 부족했다.  
　  
**CGI 기술 등장**: HTTP의 요청으로 인해 실행되는 프로그램이다. 이로인해 같은 요청의 처리 결과로 다른 콘텐츠, 즉 동적 콘텐츠를 반환할 수 있게 되었다. 처리를 요청할 때마다 프로그램이 실행된다는 점과(생명주기 X) 세션 관리가 없다는 점이 문제가 되었다. 이는 이용자가 많아지면 많아질수록 커다란 성능 문제를 일으키고 트랜잭션 관리의 어려움을 초래했다.  
　  
**JSP, Servlet 등장**: 위의 문제점을 해결하고자 등장했다. 멀티 스레드로 실행되며, 컨테이너를 통한 세션 관리를 알아서 해주어 개발자가 이를 신경쓰지 않아도 되게 해주었다. 또한 페이지 생성 로직과 비즈니스 로직을 분리하기 곤란했던 CGI와 달리 JSP로 페이지를 생성하고 Servlet으로 비즈니스 로직을 처리할 수 있게 해주는 크 장점을 가져 널리 보급되었다.

> ### EJB의 등장과 쇠퇴
>> EJB 컨테이너에 의해 분산된 EJB 컴포넌트를 마치 같은 머신에 있는 것처럼 접근할 수 있게 하거나, 분산된 데이터베이스의 트랜잭션을 마치 하나의 데이터베이스만 있는 것처럼 제어할 수 있는 분산 처리와 분산 트랜잭션의 융합 컴포넌트로 탄생한 기술이다.  
　  
이렇게 탄생했지만 웹 애플리케이션용 **재사용할 수 있는 컴포넌트**나 **SQL 기술이 필요 없는 DB 액세스 프레임워크**라는 오해를 받아 그렇게 되버렸다. 이에 따라 JSP, Servlet으로 프레젠테이션을 구현하고 EJB로 비즈니스 로직을 구현하는 것이 웹 앱의 권장 설계가 되었다.  
　  
그런데 실제 웹 애플리케이션은 분산 처리를 거의 사용하지 않으며 로컬 액세스가 필요하기 때문에 EJB는 부적합 했고, EJB 컨테이너에 의존하는 EJB는 테스트하기도 어려웠고, 사양도 복잡해 많은 개발자들이 멀리하게 되었다.  
　  
이는 스프링의 탄생 배경이 되었고 현재 EJB 3이후(이전과는 아예 다른 제품이다) 오히려 EJB는 스프링을 따라갔다.

> ### 스프링의 등장
>> 복잡하고 무거워진 J2EE의 컨테이너를 대신할 경랑 컨테이너 스프링이 등장했다.(지금은 스프링도 많이 무거워졌다.) 스프링은 DIxAOP 컨테이너인데, EJB의 장점인 트랜잭션 관리를 POJO라고 부르는 일반 자바 오브젝트로 구현할 수 있다. 또한 기존 EJB 컨테이너에 실어야 했던 EJB 컴포넌트는 EJB에 대한 의존으로 인해 테스트하기 어려웠는데, DIxAOP 컨테이너에는 POJO 오브젝트를 싣고 DI 컨테이너에 의존하지 않는다는 특징 덕분에 테스트도 쉽게 할 수 있다.

> ### 스프링의 현재
>> 사실상 표준이다. 우리나라에서도 전자 정부 표준 프레임워크이다. 자바가 클라우드를 향해 진화하므로 클라우드를 지향하는 스프링은 더욱 더 중요해질 것이다.

* * *
## 애플리케이션 아키텍처
> ### 애플리케이션 아키텍처의 필요성
>> #### 웹 애플리케이션 개발의 목표
1. 유스 케이스 등으로 표현되는 사용자 요구사항을 만족하다는 목표
2. 개발 기간 엄수나 변경, 기능 추가의 용이성, 테스트의 용이성 등 개발자나 운영자를 위한 목표  
**개발 효율**
    * 의도를 파악하기 쉽고 이해하기 쉬운 구조
    * 테스트하기 쉬운 구조  

>>> **유연성**
	* 변경하기 쉽고 기능을 추가하기 쉬운 구조
	* 미래의 환경 변화에 대응할 수 있는 견고한 구조

>>> 물론 2번째의 목표를 만족하기 위해서는 사용자 요구사항을 만족하는 것이 전제 조건이다.

>> #### 개발 효율성과 애플리케이션 아키텍처의 필요성
>>> 이해하기 쉽고 간단히 사용할 수 있어야 한다. 
  테스트도 마찬가지로 어떤 오브젝트를 테스트하기 위해 컨테이너를 꼭 준비해야 하거나 이것저것 설정해야 하거나 테스트를 위해 구현을 변경하는 것은 귀찮은 작업이다. 테스트는 간단하게 실행할 수 있는 것이 좋다.

>> #### 웹 애플리케이션의 생명주기와 애플리케이션 아키텍처의 필요성
>>> 사용자의 요구가 쉽게 변하기 때문에 요구 변화 -> 변경 및 기능 추가 -> 릴리스 이 생명주기가 계속 반복된다. 따라서 아키텍처가 유연하지 못하다면 요구 변화에 대응하지 못해 애플리케이션을 유지하기 어려워진다.

>> #### 애플리케이션 아키텍처는 자유로운 발상으로
>>> 사용자의 요구나 여러 조건에 따라 JSP(MVC로 치면 View로 볼 수 있음)로 데이터베이스에 직접 접근하는 것도 좋은 방법이다. 정석이라는 이유로 안 된다고 하는 것은 창조력을 방해한다.  
　  
사용자의 요구, 개발자/운영자의 요구 두 가지 목표를 만족하는 애플리케이션 아키텍처가 프레임워크나 라이브러리로 구현돼 매뉴얼과 함께 초기 개발 단계에서 개발자에게 제공되는 개발을 지향하여야 한다.

> ### 티어와 레이어
>> **티어**는 클라이언트(PC나 스마트폰 등), 중간(애플리케이션 서버), EIS(DB, 레거시 시스템) 3 층을 기본으로 하는 물리층이다.  
　  
**레이어**는 기본적으로 중간층에 있는 웹 애플리케이션을 논리적으로 분류한 것이다. 그러나 무조건적으로 레이어가 중간층에만 존재하는 것이 아니고 스마트폰 등인 경우 레이어의 일부가 클라이언트에 존재한다. 레이어는 서로 인접한 레이어끼리만 단방향 액세스를 할 수 있다. 일반적으로 다음처럼 3층으로 나뉜다.
* **프레젠테이션 층**: UI와 컨트롤러를 제공한다. Controller나 Action이 붙은 클래스가 배치된다.
* **비즈니스 로직 층**: Service가 붙은 유스 케이스를 제어하는 클래스나 액터 클래스가 배치된다.
* **데이터 액세스 층**: 데이터베이스 액세스를 추상화한다. 클래스 이름 끝에 DAO(Data Access Object)가 붙는다.

>> 　  
용어들은 다른 이름이 붙기도 하지만 용어가 통일되지 않으면 개발자 사이의 의사소통을 방해하므로 용어를 통일해야 한다.  
　  
컨트롤러
: 화면 전환이나 화면에서 버튼을 눌렀을 때의 동작 제어 또는 세션 관리 등을 함

>> 비즈니스 로직
서비스(애플리케이션)
: 유스 케이스로 표현되는 특정 업무나 특정 부서 처리의 통합, 트랜잭션의 기점, 일반적으로 자신의 상태를 나타내는 값을 가지지 않는 클래스

>> 도메인
: 서비스로부터 비즈니스를 실행하는 데 반드시 사용하는 고객과 주문같은 클래의 집함. 자신이 무엇인지 나타내는 값과 그 값을 이용한 처리를 실현

>> 레이어끼리 단방향 액세스가 아닌 상호 의존을 하고 있는 관계라면 리팩토링 하는것이 좋다.

> ### 오목형 레이어
>> 웹 애플리케이션의 레이어는 크게 **비즈니스와 관련된 부분**과 **비즈니스 로직의 결과를 어떻게 표현할지** 구현하는 두 부분으로 나뉠 수 있다. 비즈니스 로직의 결과를 어떻게 다룰지 구현하는 기술이 비즈니스 로직에 영향을 미치지 않는 것이 좋은 설계이다. 결과를 표현하는 방법은 화면에 표시, DB에 저장으로 나뉘는데 기존 세로형 레이어의 형태로는 불가능하다. 따라서 등장한 것이 오목형 레이어이다.

{% include figure.html src="/assets/img/web-app-layer.png" figcaption="오목형 레이어 UML" %}

>> **안정 의존 원칙**과 **의존 관계 역전 원칙** 등에 뒷받침된 건실한 구조이다.  
비즈니스 로직 층이 가장 안정돼야 하므로 가장 밑에 있는 안정 의존 원칙과 다른 패키지에 가장 큰 영향을 줄 것 같은 위치에 데이터 액세스 층이 있으므로 비즈니스 로직 층과 의존 관게를 역전한 구조이다.

* * *
## 프레젠테이션 층의 역할
> 주된 역할은 사용자 인터페이스와 컨트롤러를 제공하는 것이다.  
　  
UI는 보통 화면을 가르키는 것으로 한다.  
　  
컨트롤러는 UI의 입력을 받아 비즈니스 로직을 호출하고, 그 결과를 UI에 반환하는 작업을 한다.

> ### MVC2란?
>> 예전 J2EE의 MVC2는 MVC 패턴을 참고한 것으로, **M**odel 부분에 EJB, **V**iew 부분에 JSP, **C**ontroller 부분에 Servlet을 사용한다.

{% include figure.html src="/assets/img/MVC2.png" figcaption="J2EE의 MVC2" %}

>> 스프링에서 일반적으로 컨트롤러는 스프링 MVC를 사용한다. 프로젝트 때마다 처음부터 컨트롤러를 직접 만드는 것은 낭비이다.

> ### 다양화되는 사용자 인터페이스
>> 현재 UI를 구현하는 방법은 리액트, 앵귤러를 이용하는 등 매우 다양하다. 프레젠테이션 층은 사용자의 요청에 따라 패턴이 늘어 매우 다양하게 발전했다. 이에 따라 아키텍처 면에서 구문 검증은 웹 애플리케이션 중간 층에서 실행되지만, Ajax를 사용한 경우 클라이언트 층에서 실행될 때도 있다. 스마트폰 등에서는 그 자체를 클라이언트 층으로 보고 별도의 애플리케이션 레이어를 배치하기도 한다.

* * *
## 비즈니스 로직 층의 역할
> 웹 애플리케이션의 중심.  
　   
기능 추가와 변경은 주로 비즈니스 로직 층의 로직 변경임. 프레젠테이션 층과 데이터 액세스 츠에서는 신뢰성 있는 프레임워크를 이용하면 장애 등의 리스크를 거의 피할 수 있으나 비즈니스 로직에는 업무용 프레임워크가 적다. 더군다나 비즈니스 로직 층에서 구현하고 싶은 업무를 가장 잘 아는 것은 개발자가 아닌 사용자이다. 실패한 프로젝트의 대부분은 사용자와의 커뮤니케이션 문제, 비즈니스 로직 층의 구조 문제였다.

> ### 비즈니스 로직 층의 패턴
>> 
>> #### 트랜잭션 스크립트
>>> 데이터베이스의 내용을 표시/변경하기만 하는 업무 처리, 즉 비즈니스 로직이 적은 단순 입출력 애플리케이션일 때는 로직을 전부 서비스 클래스에 포함시키는 편이 좋다. 이로인해 도메인은 그저 값을 저장하기만 하므로 VO(Value Object)나 DTO(Data Transfer Objet)라고 부르는 것이 된다.

>> #### 도에인 모델
>>> 비즈니스 로직이 복잡해짐에 따라 트랜잭션 스크립트만으로 개발하면 굉장히 복잡해질 수 있다. 이에따라 도메인에 로직을 포함시키는 것이 좋지만 한계를 느끼면 트랜잭션 스크립트로 전환하는 것이 좋다.  
　  
**스프링은 도메인 모델에 도움이 되지 않는다.**
도메인 모델은 도메인에게 값을 처리할 것을 요구하는데, 스프링에서 도메인의 생성과 관리는 DIxAOP 컨테이너가 아닌 데이터 액세스 층의 구조에 의존하기 때문이다.

> ### 트랜잭션 관리
>> 간단히 말하면 처리 단위이다. 웹 사이트에서 검색해서 상품 목록을 보는 과정도 트랜잭션이고, 웹 사이트에서 상품을 주문해서 집에 도착하기까지도 하나의 긴 트랜잭션이다. 다양한 트랜잭션이 있지만 여기서는 데이터베이스 트랜잭션만 다룬다.  
　  
트랜잭션에서는 ACID라는 지켜야 할 특성이 존재한다. 이 중 신경써야 하는 것은 A와 I이다.

<table>
	<tbody>
		<tr>
			<th style="width: 20%">ACID</th>
			<th style="width: 20%">의미</th>
			<th style="width: 60%">설명</th>
		</tr>
		<tr>
			<td>Atomicity</td>
			<td>트랜잭션의 원자성</td>
			<td>트랜잭션 내의 모든 처리는 전부 실행됐거나 아무것도 실행되지 않았다.</td>
		</tr>
		<tr>
			<td>Consistency</td>
			<td>데이터의 일관성</td>
			<td>데이터에 일관성이 있어야 한다.
			-일관성을 지키지 않은 예: 상위 테이블이 없는데 하위 테이블이 있는 경우</td>
		</tr>
		<tr>
			<td>Isolation</td>
			<td>트랜잭션의 독립성</td>
			<td>병행해서 달리는 트랜잭션이 서로 독립된 것</td>
		</tr>
	</tbody>
</table>

- 작성중